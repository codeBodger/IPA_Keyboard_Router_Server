/* autogenerated by Processing revision 1293 on 2024-06-11 */
/* modified by Rowan Ackerman thereafter */

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.TimeZone;
import java.util.Timer;
import java.util.TimerTask;

public class IPA_Keyboard_Router_Server {

public static final long DELAY_HOURS = 1;
public static final long DELAY_MILLIS = 1000 * 60 * 60 * DELAY_HOURS;
// public static final long DELAY_MILLIS = 1000 * 60 * 2;

sServer sJava;
sServer sPython;
HashMap<String, sClient> ipClients = new HashMap<String, sClient>();
HashMap<String, sClient> keyClients = new HashMap<String, sClient>();
// int val = 0;
Timer timer = new Timer();
TimerTask removeUnused = new TimerTask() {
  @Override
  public void run() {
    kickAndUpdate(keyClients);
    kickAndUpdate(ipClients);
  }

  private void kickAndUpdate(HashMap<String, sClient> clients) {
    for (Map.Entry<String, sClient> clientMap : clients.entrySet()) {
      sClient client = clientMap.getValue();
      String keyOrIP = clientMap.getKey();
      if (client.timeoutNextHour) {
        clients.remove(keyOrIP);
        client.write(-1);
        println("Kicked " + keyOrIP);
        client = null;
        return;
      }
      client.timeoutNextHour = true;
    }
  }
};

public void setup() {
  // Starts a server on port 8000 to connect to the Clients
  sJava = new sServer(this, 8000);

  // Starts a server on port 8001 to connect to the Python server
  sPython = new sServer(this, 8001);
  
  println("Server started on " + sServer.ip());

  timer.schedule(removeUnused, DELAY_MILLIS, DELAY_MILLIS);
}

public void draw() {
  throw new Error();
}

public void clientEvent(sClient C) {
  int dataIn = C.read();
  String key;

  switch (dataIn) {
    // If appropriate and possible, send the 2nd byte from a python client to the right java client
    case 92: // from python
      dataIn = C.read();
      key = C.readString();
      println(key + " sent " + dataIn);
      if (keyClients.containsKey(key)) {
        keyClients.get(key).write(dataIn);
      }
    break;
    
    // If appropriate and possible, move sClient C from ipClients to keyClients
    case 96: // java connect
      if (ipClients.containsKey(C.ip())) {
        key = C.readString();
        println(key + " linked to " + C.ip());
        keyClients.put(key, ipClients.get(C.ip()));
        ipClients.remove(C.ip());
      }
    break;
  }
}

// New Client C just connected to Server S
public void serverEvent(sServer S, sClient C) {
  if (S.getPort() != 8000) return;
  ipClients.put(C.ip(), C);
  println(C.ip() + " connected");
}

  static public void main(String[] passedArgs) {
    runSketch();
  }

  static void runSketch() {
    final String name = "IPA_Keyboard_Router_Server";
    
    final IPA_Keyboard_Router_Server sketch;
    try {
      Class<?> c = Thread.currentThread().getContextClassLoader().loadClass(name);
      sketch = (IPA_Keyboard_Router_Server) c.getDeclaredConstructor().newInstance();
    } catch (RuntimeException re) {
      // Don't re-package runtime exceptions
      throw re;
    } catch (Exception e) {
      // Package non-runtime exceptions so we can throw them freely
      throw new RuntimeException(e);
    }

    sketch.setup();
  }

  static void println(String str) {
    final Date currentTime = new Date();

    final SimpleDateFormat sdf =
            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss\t");

    // Give it to me in GMT time.
    sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
    System.out.println(sdf.format(currentTime) + str);
  }
}
